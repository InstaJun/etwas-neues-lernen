其实要理解`.C`文件与`.H`头文件有什么不同之处，首先需要弄明白编译器的工作过程，一般说来编译器会做以下几个过程： 
- 预处理阶段 (#include<.h>)
- 词法与语法分析阶段 
- 编译阶段，首先编译成纯汇编语句，再将之汇编成跟CPU相关的二进制码，生成各个目标文件 
- 连接阶段，将各个目标文件中的各段代码进行绝对地址定位，生成跟特定平台相关的可执行文件，当然，最后还可以用objcopy生成纯二进制
码，也就是去掉了文件格式信息.

**对头文件的理解**

那是一个被遗忘的年代,在编译器只认识.c(.cpp))文件，而不知道.h是何物的年代。
那时的人们写了很多的.c(.cpp)文件，渐渐地，人们发现在很多.c(.cpp)文件中的<u>声明语句</u>就是相同的，但他们却不得不一个字一个字地重复地将这些内容敲入每个.c(.cpp)文件。但更为恐怖的是，当其中一个声明有变更时，就需要检查所有的.c(.cpp)文件，并修改其中的声明,啊~简直是世界末日降临!

终于，有人（或许是一些人）再不能忍受这样的折磨，他（们）将重复的部分提取出来，放在一个新文件里,然后在需要的.c(.cpp)文件中敲入#include   XXXX这样的语句。这样即使某个声明发生了变更，也再不需要到处寻找与修改了。

因为这个新文件，经常被放在.c(.cpp)文件的头部，所以就给它起名叫做“`文件`，扩展名是`.h`.
从此，编译器（其实是预处理器）就知道世上除了.c(.cpp)文件，还有个.h的文件，以及一个叫做`#include`命令。

**对`.c`文件理解**
<u>编译器在编译时是以**C文件**为单位进行的</u>，也就是说如果你的项目中一个C文件都没有，那么你的项目将无法编译，<u>连接器是以目标文件为单位</u>，它将一个或多个目标文件进行函数与变量的重定位，生成最终的可执行文件，在PC上的程序开发，一般都有一个main函数，这是各个编译器的约定，当然，你如果自己写连接器脚本的话，可以不用main函数作为程序入口！！

有了这些基础知识，再言归正传，为了生成一个最终的可执行文件，就需要一些目标文件，也就是需要C文件，而这些C文件中又需要一个`main函数`作为可执行程序的入口，那么我们就从一个C文件入手，假定这个C文件内容如下： 

~~~c
\#include <stdio.h> 
\#include "mytest.h"

int main(int argc,char **argv) 
{ 
test = 25; 
printf("test.................%d\n",test); 
}
~~~
头文件内容如下： 
~~~C
int test;
~~~

## 编译器的工作： 
1.预处理阶段：
编译器以C文件作为一个单元，首先读这个C文件，发现第一句与第二句是包含一个头文件，就会在所有搜索路径中寻找这两个文件，找到之后，就会将相应头文件中再去处理宏，变量，函数声明,嵌套的头文件包含等，检测依赖关系，进行宏替换，看是否有重复定义与声明的情况发生，最后将那些文件中所有的东东全部扫描进这个当前的C文件中，形成一个中间“C文件”

2.编译阶段，
在上一步中相当于将那个头文件中的test变量扫描进了一个中间C文件，那么test变量就变成了这个文件中的一个全局变量，此时就将所有这个中间C文件的所有变量，函数分配空间，将各个函数编译成二进制码，按照特定目标文件格式生成目标文件，在这种格式的目标文件中进行各个全局变量，函数的符号描述，将这些二进制码按照一定的标准组织成一个目标文件

3.连接阶段
将上一步成生的各个目标文件，根据一些参数，连接生成最终的可执行文件，主要的工作就是重定位各个目标文件的函数，变量等，相当于将个目标文件中的二进制码按一定的规范合到一个文件中


## C文件与头文件内容

>理论上来说`C文件`与`头文件`里的内容，只要是C语言所支持的，无论写什么都可以的，比如你在头文件中写函数体，只要在任何一个C文件包含此头文件就可以将这个函数编译成目标文件的一部分（编译是以C文件为单位的，如果不在任何C文件中包含此头文件的话，这段代码就形同虚设），你可以在C文件中进行函数声明，变量声明，结构体声明，这也不成问题！！！

那为何一定要分成头文件与C文件呢？又为何一般都在头件中**进行函数，变量声明，宏声明，结构体声明**呢？而在C文件中去进行**变量定义，函数实现**呢？原因如下：

>1.如果在头文件中实现一个函数体，那么如果在多个C文件中引用它，而且又同时编译多个C文件，将其生成的目标文件连接成一个可执行文件，在每个引用此头文件的C文件所生成的目标文件中，都有一份这个函数的代码，如果这段函数又没有定义成局部函数，那么在连接时，就会发现多个相同的函数，就会报错

>2.如果在头文件中定义全局变量，并且将此全局变量赋初值，那么在多个引用此头文件的C文件中同样存在相同变量名的拷贝，关键是此变量被赋了初值，所以编译器就会将此变量放入DATA段，最终在连接阶段，会在DATA段中存在多个相同的变量，它无法将这些变量统一成一个变量，也就是仅为此变量分配一个空间，而不是多份空间，假定这个变量在头文件没有赋初值，编译器就会将之放入BSS段，连接器会对BSS段的多个同名变量仅分配一个存储空间

>3.如果在C文件中声明宏，结构体，函数等，那么我要在另一个C文件中引用相应的宏，结构体，就必须再做一次重复的工作，如果我改了一个C文件中的一个声明，那么又忘了改其它C文件中的声明，这不就出了大问题了，程序的逻辑就变成了你不可想象的了，如果把这些公共的东东放在一个头文件中，想用它的C文件就只需要引用一个就OK了！这样岂不方便，要改某个声明的时候，只需要动一下头文件就行了

>4.在头文件中声明结构体，函数等，当你需要将你的代码封装成一个库，让别人来用你的代码，你又不想公布源码，那么人家如何利用你的库呢？也就是如何利用你的库中的各个函数呢？？一种方法是公布源码，别人想怎么用就怎么用，另一种是提供头文件，别人从头文件中看你的函数原型，这样人家才知道如何调用你写的函数，就如同你调用printf函数一样，里面的参数是怎样的？？你是怎么知道的？？还不是看人家的头文件中的相关声明啊！！！当然这些东东都成了C标准，就算不看人家的头文件，你一样可以知道怎么使用



Quelle：https://blog.csdn.net/21aspnet/article/details/149810



